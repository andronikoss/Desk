bc.test(model.est)
x == F
matrix(NA, 3,4)
is.character(matrix(NA, 3,4))
matrix(NA, 3,4) == "none"
is.matrix(x)
class(x)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
x <− c(0.6, 1.1, 1.7, 2.2, 2.8, 3.3, 3.9, 4.4, 5.0)
y <− c(1.6, 2.9, 3.4, 4.5, 6.6, 7.4, 7.9, 9.9, 11.9)
model.est <− ols(y ~ x)
bc.test(model.est, trans.exo = log(x))
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
x <− c(0.6, 1.1, 1.7, 2.2, 2.8, 3.3, 3.9, 4.4, 5.0)
y <− c(1.6, 2.9, 3.4, 4.5, 6.6, 7.4, 7.9, 9.9, 11.9)
model.est <− ols(y ~ x)
bc.test(model.est, trans.exo = log(x))
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
x <− c(0.6, 1.1, 1.7, 2.2, 2.8, 3.3, 3.9, 4.4, 5.0)
y <− c(1.6, 2.9, 3.4, 4.5, 6.6, 7.4, 7.9, 9.9, 11.9)
model.est <− ols(y ~ x)
bc.test(model.est, trans.exo = log(x))
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
x <− c(0.6, 1.1, 1.7, 2.2, 2.8, 3.3, 3.9, 4.4, 5.0)
y <− c(1.6, 2.9, 3.4, 4.5, 6.6, 7.4, 7.9, 9.9, 11.9)
model.est <− ols(y ~ x)
bc.test(model.est, trans.exo = log(x))
log(x) == "same"
any(log(x) == "same")
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
x <− c(0.6, 1.1, 1.7, 2.2, 2.8, 3.3, 3.9, 4.4, 5.0)
y <− c(1.6, 2.9, 3.4, 4.5, 6.6, 7.4, 7.9, 9.9, 11.9)
model.est <− ols(y ~ x)
bc.test(model.est, exo = log(x))
rent <− data.comp$rent
mult <− data.comp$mult
mem <− data.comp$mem
access <− data.comp$access
lin.est <− ols(rent ~ mult + mem + access)
linlog.est <− ols(rent ~ log(mult) + log(mem) + log(access))
log.est <− ols(log(rent) ~ log(mult) + log(mem) + log(access))
loglin.est <− ols(log(rent) ~ mult + mem + access)
bc.test(lin.est, exo = cbind(log(mult), log(mem), log(access)))
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
bc.test(lin.est, exo = cbind(log(mult), log(mem), log(access)))
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
bc.test(lin.est, exo = cbind(log(mult), log(mem), log(access)))
bc.test(lin.est)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
bc.test(lin.est)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
bc.test(lin.est)
bc.test(lin.est, exo = cbind(log(mult), log(mem), log(access)))
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
bc.test(lin.est, exo = cbind(log(mult), log(mem), log(access)))
bc.test(lin.est)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
bc.test(lin.est)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
lin.est$data
lin.est <− ols(rent ~ mult + mem + access, data = data.comp)
A = lin.est$data
bc.test(model.est, exo = cbind(log(A$mult), log(A$mem), log(A$access)))
cbind(log(A$mult), log(A$mem), log(A$access))
class(cbind(log(A$mult), log(A$mem), log(A$access)))
cbind(log(mult), log(mem), log(access))
lin.est <− ols(rent ~ mult + mem + access, data = data.comp)
A = lin.est$data
bc.test(model.est, exo = cbind(log(mult), log(mem), log(access)))
cbind(log(mult), log(mem), log(access)))
cbind(log(mult), log(mem), log(access))
bc.test(lin.est, exo = cbind(log(mult), log(mem), log(access)))
bc.test(lin.est, exo = cbind(log(A$mult), log(A$mem), log(A$access)))
lin.est <− ols(rent ~ mult + mem + access, data = data.comp)
A = lin.est$data
bc.test(lin.est, exo = log(cbind(A$mult, A$mem, A$access)))
bc.test(lin.est)
library(desk)
?match.arg
?t.coef.test
fert.est <- ols(barley ~ phos + nit, data = log(data.fertilizer))
x = t.coef.test(fert.est, nh = c(0,1,1), q = 1, details = T)
x # Show the test results
t.coef.test(barley ~ phos + nit, data = log(data.fertilizer), nh = c(0,1,1), q = 1, details = T)
source.with.encoding('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/t.coef.test.R', encoding='UTF-8', echo=TRUE)
t.coef.test(barley ~ phos + nit, data = log(data.fertilizer), nh = c(0,1,1), q = 1, details = T)
fert.est <- ols(barley ~ phos + nit, data = log(data.fertilizer))
x = t.coef.test(fert.est, nh = c(0,1,1), q = 1, details = T)
x # Show the test results
?qlr.test
unemp.mod = ols(unempl ~ gdp, data = data.unempl)
my.qlr = qlr.test(unemp.mod, from = 13, to = 17, details = T)
my.qlr$results
plot(my.qlr)
unemp.mod = ols(unempl ~ gdp, data = data.unempl)
my.qlr = qlr.test(unemp.mod, from = 13, to = 17, details = T)
my.qlr$results
plot(my.qlr)
my.qlr = qlr.test(unempl ~ gdp, data = data.unempl, from = 13, to = 17, details = T)
source.with.encoding('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/qlr.test.R', encoding='UTF-8', echo=TRUE)
my.qlr = qlr.test(unempl ~ gdp, data = data.unempl, from = 13, to = 17, details = T)
my.qlr$results
my.qlr
source.with.encoding('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/f.coef.test.R', encoding='UTF-8', echo=TRUE)
x = f.coef.test(ols(barley ~ phos + nit, data = log(data.fertilizer)),
nh = rbind(c(0,1,0), c(0,0,1)),
q = c(0.33,0.33),
details = T)
x # Show the test results
plot(x) # Visualize the test result
plot(x, plot.what = "ellipse", q = c(0.33, 0.33))
f.coef.test(barley ~ phos + nit, data = log(data.fertilizer),
nh = rbind(c(0,1,0), c(0,0,1)),
q = c(0.33,0.33),
details = T)
x = f.coef.test(barley ~ phos + nit, data = log(data.fertilizer),
nh = rbind(c(0,1,0), c(0,0,1)),
q = c(0.33,0.33),
details = T)
x # Show the test results
plot(x) # Visualize the test result
plot(x, plot.what = "ellipse", q = c(0.33, 0.33))
sales.est <- ols(sales ~ price, data = data.filter)
# In this example regressions over 199 rho values between -1 and 1 are carried out
# The one with minimal SSR is printed out
hilu(sales.est)
names(hilu(sales.est))
sales.est <- ols(sales ~ price, data = data.filter)
# In this example regressions over 199 rho values between -1 and 1 are carried out
# The one with minimal SSR is printed out
hilu(sales.est)
# Direct usage of a model formula
X <- hilu(sick ~ jobless, data = data.sick[1:14,], details = T)
# Print full details
X
# Suppress details
print(X, details = F)
# Plot SSR over rho-values to see minimum
plot(X)
A = ivr(contr ~ score, endog = "score", iv = "contrprev", data = data.insurance, details = T)
names(A)
A$data.name
A$exogenous
A$exogeneous
A$fst
A$instrumented
A$instruments
endog = c("PRICE")
iv = c("WINDSPD","WINDSPD2", "STORMY", "COLD", "RAINY", "MIXED")
ivr(QTY ~ PRICE + DAY1 + DAY2 + DAY3 + DAY4, endog = endog, iv = iv, details = T, data = data.graddy)
endog = c("QTY")
iv = iv = c("DAY1", "DAY2", "DAY3", "DAY4")
ivr(PRICE ~ QTY + WINDSPD + WINDSPD2 + STORMY + COLD + RAINY + MIXED, endog = endog, iv = iv, details = T, data = data.graddy)
load("O:/Dropbox/Oekonometrie/OekoUB/Package/desk/data/data.murray.rda")
rm.all()
load("O:/Dropbox/Oekonometrie/OekoUB/Package/desk/data/data.murray.rda")
View(data.murray)
library(foreign)
data.educwages <- read.dta("http://www.stata-press.com/data/r12/educwages.dta")
ivr(wages ~ union + education, endog = "education", iv = c("meducation", "feducation"), data = data.educwages)
A = ivr(wages ~ union + education, endog = "education", iv = c("meducation", "feducation"), data = data.educwages)
names(A)
print(A, details = T)
read.table(http://wps.aw.com/wps/media/objects/2387/2445250/Data_Sets/ASCII/whiting.csv)
read.table("http://wps.aw.com/wps/media/objects/2387/2445250/Data_Sets/ASCII/whiting.csv")
read.table("http://wps.aw.com/wps/media/objects/2387/2445250/Data_Sets/ASCII/whiting.csv", header = T)
read.table("http://wps.aw.com/wps/media/objects/2387/2445250/Data_Sets/ASCII/whiting.csv", header = T, delim = ",")
?read.table
read.table("http://wps.aw.com/wps/media/objects/2387/2445250/Data_Sets/ASCII/whiting.csv", header = T, sep = ",")
data.graddy = read.table("http://wps.aw.com/wps/media/objects/2387/2445250/Data_Sets/ASCII/whiting.csv", header = T, sep = ",")
ivr(QTY ~ PRICE, endog = c("PRICE"), iv = "WINDSPD", details = T, data = data.graddy)
endog = c("PRICE")
iv = c("WINDSPD","WINDSPD2", "STORMY", "COLD", "RAINY", "MIXED")
ivr(QTY ~ PRICE + DAY1 + DAY2 + DAY3 + DAY4, endog = endog, iv = iv, details = T, data = data.graddy)
endog = c("QTY")
iv = iv = c("DAY1", "DAY2", "DAY3", "DAY4")
ivr(PRICE ~ QTY + WINDSPD + WINDSPD2 + STORMY + COLD + RAINY + MIXED, endog = endog, iv = iv, details = T, data = data.graddy)
consump <- data.kmenta$consump
price <- data.kmenta$price
income <- data.kmenta$income
farmPrice <- data.kmenta$farmPrice
trend <- data.kmenta$trend
# Define model equations:
eqD <- consump ~ price + income
eqS <- consump ~ price + farmPrice + trend
# Estimate demand function with instruments "farmPrice"" and "trend""
D.est <- ivr(mod = eqD, endog = "price", iv = c("farmPrice", "trend"))
# Estimate supply function with instrument "income"
S.est <- ivr(mod = eqS, endog = "price", iv = "income")
# Calculate y-axis intersection and slope with averaged exogenous regressors
aD <- c(1, mean(income)) \%*\% D.est$coef[-2]
bD <- D.est$coef[2]
aS <- c(1, mean(farmPrice), mean(mean(trend))) \%*\% S.est$coef[-2]
bS <- S.est$coef[2]
# Plot data and estimated functions
plot(price, consump, xlim = c(0,120), ylim = c(0,120))
abline(a = aD, b = bD)
abline(a = aS, b = bS)
?ivr
consump <- data.kmenta$consump
price <- data.kmenta$price
income <- data.kmenta$income
farmPrice <- data.kmenta$farmPrice
trend <- data.kmenta$trend
# Define model equations:
eqD <- consump ~ price + income
eqS <- consump ~ price + farmPrice + trend
# Estimate demand function with instruments "farmPrice"" and "trend""
D.est <- ivr(mod = eqD, endog = "price", iv = c("farmPrice", "trend"))
# Estimate supply function with instrument "income"
S.est <- ivr(mod = eqS, endog = "price", iv = "income")
# Calculate y-axis intersection and slope with averaged exogenous regressors
aD <- c(1, mean(income)) %*% D.est$coef[-2]
bD <- D.est$coef[2]
aS <- c(1, mean(farmPrice), mean(mean(trend))) %*% S.est$coef[-2]
bS <- S.est$coef[2]
# Plot data and estimated functions
plot(price, consump, xlim = c(0,120), ylim = c(0,120))
abline(a = aD, b = bD)
abline(a = aS, b = bS)
X <- jb.test(data.income$loginc)
X
# Estimate linear model
income.est <- ols(loginc ~ logsave + logsum, data = data.income)
# Test residuals for normality, print details
jb.test(income.est, details = T)
# Equivalent test
jb.test(loginc ~ logsave + logsum, data = data.income, details = T)
# Plot the test result
plot(X)
names(jb.test(loginc ~ logsave + logsum, data = data.income, details = T))
log
methods(log)
GoAnywhere(log.def)
Goanywhere(log.def)
log.def
par(mfrow=c(2,2))
A.dat = makedata.bc(a = 3) # linear data shifted by 3
B.dat = makedata.bc(lambda.y = 0, n = 100, sigma = 0.2, x.max = 3, seed = 123) # log transformed y-data
C.dat = makedata.bc(lambda.y = 6, sigma = 0.4, seed = 12)# concave scatter
D.dat = makedata.bc(lambda.x = 0, lambda.y = 6, sigma = 0.4, seed = 12)# concave scatter, x transf.
plot(A.dat)
plot(B.dat)
plot(C.dat)
plot(D.dat)
par(mfrow=c(1,1))
#par(mfrow=c(2,2))
A.dat = makedata.bc(a = 3) # linear data shifted by 3
B.dat = makedata.bc(lambda.y = 0, n = 100, sigma = 0.2, x.max = 3, seed = 123) # log transformed y-data
C.dat = makedata.bc(lambda.y = 6, sigma = 0.4, seed = 12)# concave scatter
D.dat = makedata.bc(lambda.x = 0, lambda.y = 6, sigma = 0.4, seed = 12)# concave scatter, x transf.
plot(A.dat, main = "linear data shifted by 3")
plot(B.dat, main = "log transformed y-data")
plot(C.dat, main = "concave scatter")
plot(D.dat, main = "concave scatter, x transf.")
par(mfrow=c(1,1))
par(mfrow=c(2,2))
A.dat = makedata.bc(a = 3) # linear data shifted by 3
B.dat = makedata.bc(lambda.y = 0, n = 100, sigma = 0.2, x.max = 3, seed = 123) # log transformed y-data
C.dat = makedata.bc(lambda.y = 6, sigma = 0.4, seed = 12)# concave scatter
D.dat = makedata.bc(lambda.x = 0, lambda.y = 6, sigma = 0.4, seed = 12)# concave scatter, x transf.
plot(A.dat, main = "linear data shifted by 3")
plot(B.dat, main = "log transformed y-data")
plot(C.dat, main = "concave scatter")
plot(D.dat, main = "concave scatter, x transf.")
par(mfrow=c(1,1))
makedata.bc(lambda.y = 0, n = 100, sigma = 0.2, x.max = 3, seed = 123)
source('~/.active-rstudio-document', echo=TRUE)
makedata.bc(lambda.y = 0, n = 100, sigma = 0.2, x.max = 3, seed = 123)
source('~/.active-rstudio-document', echo=TRUE)
makedata.bc(lambda.y = 0, n = 100, sigma = 0.2, x.max = 3, seed = 123)
source('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/exp.def.R', echo=TRUE)
# Generate desired correlation structure
corr.mat = cbind(c(1, 0.7),c(0.7, 1))
# Generate 10 observations of 2 exogenous variables
X = makedata.corr(n = 10, k = 2, CORR = corr.mat)
cor(X) # not exact values of corr.mat
# Same structure applied to a sample
X = makedata.corr(n = 10, k = 2, CORR = corr.mat, sample = T)
cor(X) # exact values of corr.mat
mc.table(data.printer[,-1])
y = c(4,1,2,1)
x1 = c(4,1,3,2)
x2 = c(3,4,4,2)
my.modA = lm(y~x1+x2)
my.modB = lm(y~0+x1+x2)
ols.has.const(my.modA)
ols.has.const(my.modB)
y = c(4,1,2,1)
x1 = c(4,1,3,2)
x2 = c(3,4,4,2)
my.modA = ols(y ~ x1 + x2)
my.modB = ols(y ~ 0 + x1 + x2)
ols.has.const(my.modA)
ols.has.const(my.modB)
y = c(4,1,3)
x = c(1,2,4)
my.mod = ols(y ~ x)
ols.infocrit(my.mod) # Return all criteria unscaled
ols.infocrit(my.mod, scaled = T) # Return all criteria scaled
ols.infocrit(my.mod, which = "pc") # Return Prognostic Criterion unscaled
?bc.test
lin.est <- ols(rent ~ mult + mem + access, data = data.comp)
A = lin.est$data
bc.test(lin.est, exo = log(cbind(A$mult, A$mem, A$access)))
lin.est <- ols(rent ~ mult + mem + access, data = data.comp)
A = lin.est$data
bc.test(lin.est, exo = "blah")
source.with.encoding('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/bc.test.R', encoding='UTF-8', echo=TRUE)
lin.est <- ols(rent ~ mult + mem + access, data = data.comp)
A = lin.est$data
bc.test(lin.est, exo = "blah")
source.with.encoding('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/ols.interval.R', encoding='UTF-8', echo=TRUE)
?ols.interval
y = c(4,1,2,1)
x1 = c(4,1,3,2)
x2 = c(3,4,4,2)
modA.est = ols(y ~ x1 + x2)
modB.est = ols(y ~ 0 + x1 + x2)
my.mat = cbind(x1 = c(6,3,9), x2 = c(5,3,10))
ols.interval(modA.est) # 95% confidence intervals for all parameters
ols.interval(modA.est, which.coef = c("(Intercept)", "x2")) # 95% confidence intervals for intercept and beta2
ols.interval(modA.est, which.coef = c(1,3)) # equivalent to previous command
ols.interval(modA.est, xnew = my.mat) # 95% confidence intervals around true, constant y-values
ols.interval(modA.est, type = "acceptance", which.coef = c(2,3), q = 0.5) # ai for H0:beta1 = 0.5 and H0:beta2 = 0.5
ols.interval(modA.est, type = "acceptance", which.coef = 2, dir = "right", q = 0.5) # ai for H0:beta1 <= 0.5
ols.interval(modA.est, type = "prediction", xnew = c(x1 = 6, x2 = 5))
ols.interval(modA.est, type = "prediction", xnew = my.mat) # Three prediction intervals
ols.interval(modB.est, type = "prediction", xnew = my.mat) # Model has no intercept
?bc.test
ols.interval(rent ~ mult + mem + access, data = data.comp)
source.with.encoding('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/ols.interval.R', encoding='UTF-8', echo=TRUE)
ols.interval(rent ~ mult + mem + access, data = data.comp)
A = ols.interval(rent ~ mult + mem + access, data = data.comp)
names(A)
ols.interval(y ~ x1 + x2) # Similar to the above
y = c(4,1,2,1)
x1 = c(4,1,3,2)
x2 = c(3,4,4,2)
my.mod = ols(y ~ x1 + x2)
# Returns fitted values
ols.predict(my.mod)
# Generate new x-data
my.mat = rbind(c(x1 = 6, x2 = 5), c(x1 = 3, x2 = 3), c(x1 = 9, x2 = 10))
# Returns predicted values
ols.predict(my.mod, xnew = my.mat)
# Returns predicted values and est. var. of pred. error
ols.predict(my.mod, xnew = my.mat, details = T)
A =ols.predict(my.mod, xnew = my.mat, details = T)
names(A)
ols.predict(y ~ x1 + x2)
source.with.encoding('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/t.coef.test.R', encoding='UTF-8', echo=TRUE)
ols.predict(y ~ x1 + x2)
ols.predict(y ~ x1 + x2, data = cbind(y, x1, x2))
source.with.encoding('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/ols.predict.R', encoding='UTF-8', echo=TRUE)
ols.predict(y ~ x1 + x2, data = cbind(y, x1, x2))
ols.predict(y ~ x1 + x2, data = data.frame(y, x1, x2))
y = c(4,1,2,1)
x1 = c(4,1,3,2)
x2 = c(3,4,4,2)
my.data = data.frame(y, x1, x2)
# Returns fitted values
ols.predict(y ~ x1 + x2, data = my.data)
# Returns fitted values (equivalent to above)
my.mod = ols(y ~ x1 + x2)
ols.predict(my.mod)
# Generate new x-data
my.mat = rbind(c(x1 = 6, x2 = 5), c(x1 = 3, x2 = 3), c(x1 = 9, x2 = 10))
# Returns predicted values
ols.predict(my.mod, xnew = my.mat)
# Returns predicted values and est. var. of pred. error
ols.predict(my.mod, xnew = my.mat, details = T)
# Minimal simple regression model
check <- c(10,30,50)
tip <- c(2,3,7)
tip.est <- ols (tip ~ check)
# Equivalent estimation using data argument
tip.est <- ols (y ~ x, data = data.tip)
# Show estimation results
tip.est
# Show details
print(tip.est, details = T)
# Plot scatter and regression line
plot(tip.est)
# Plot confidence (dark) and prediction bands (light), residuals and two center lines
plot(tip.est, pred.int = T, conf.int = T, residuals = T, center = T)
# Multiple regression model
fert.est <- ols(barley ~ phos + nit, data = log(data.fertilizer), details = T)
fert.est
# Estimate model.
unemp.est <- ols(unempl ~ gdp, data = data.unempl[1:14,])
# Test for immediate structural break after t = 13
pc.test(unemp.est, split = 13)
names(pc.test(unemp.est, split = 13))
A = pc.test(unemp.est, split = 13)
A$periods1
A$periods.total
filter.est <- ols(sales ~ price, data = data.filter)
pdw(x = c(0.9, 1.7, 2.15), filter.est)
?ols
tip.est <- ols (y ~ x, data = data.tip)
class(tip.est)
# Simple regression model
tip.est <- ols (y ~ x, data = data.tip)
# Check its class
class(tip.est)
# Standard regression output
print(tip.est)
# Standard regression output with details
print(tip.est, details = T)
print(tip.est, details = T, digits = 2)
plot(tip.est)
plot(tip.est, pred.int = T, conf.int = T, resid = T)
?match.args
?match.arguments
?match.argument
source('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/qlr.cv.r', echo=TRUE)
qlr.cv(tAll = 60)
source('~/.active-rstudio-document', echo=TRUE)
qlr.cv(tAll = 60)
source('~/.active-rstudio-document', echo=TRUE)
qlr.cv(tAll = 60)
qlr.cv(tAll = 60, sig.level = 0.1)
A = qlr.cv(tAll = 60, sig.level = 0.1)
names(A)
source('O:/Dropbox/Oekonometrie/OekoUB/Package/desk/R/qlr.cv.r', echo=TRUE)
A = qlr.cv(tAll = 60, sig.level = 0.1)
A
unemp.mod = ols(unempl ~ gdp, data = data.unempl)
my.qlr = qlr.test(unemp.mod, from = 13, to = 17, details = T)
my.qlr # Print test results
plot(my.qlr)
names(my.qlr)
my.qlr
# Generate data of two predictors
x1 = c(1,2,3,4,5)
x2 = c(2,4,5,5,6)
x = cbind(x1,x2)
# Generate list of data structures and name it "out"
out = rep.sample(x, true.par = c(2,1,4), rep = 10)
# Extract some data
out$coef[2,8] # Extract estimated beta1 (i.e. 2nd coeff) in the 8th sample
out$coef["beta1","SMPL8"] # Same as above using internal names
out$confint["beta1","upper","SMPL5"] # Extract only upper bound of confidence interval of beta 1 from 5th sample
out$confint[,,5] # Extract confidence intervals (upper and lower bound) for all parameters from 5th sample
out$confint[,,"SMPL5"] # Same as above using internal names
out$confint["beta1",,"SMPL5"] # Extract confidence interval of beta 1 from 5th sample
out$u.hat[,"SMPL7"] # Extract residuals from OLS estimation of sample 7
# Generate prediction intervals at three specified points of exogenous data (xnew)
out = rep.sample(x, true.par = c(2,1,4), rep = 10, xnew = cbind(x1 = c(1.5, 6, 7), x2 = c(1, 3, 5.5)))
out$predint[,,6] # Prediction intervals at the three data points of xnew in 6th sample
out$sd.pe[,6] # Estimated standard deviations of prediction errors in 6th sample
out$outside.pi # Percentage of how many intervals miss true y0 realization
# Illustrate that the relative shares of cases when the interval does not cover the
# true value approaches the significance level
out = rep.sample(x, true.par = c(2,1,4), rep = 1000)
out$outside.ci
# Illustrate omitted variable bias
out.unbiased = rep.sample(x, true.par = c(2,1,4))
mean(out.unbiased$coef["beta1",]) # approx. equal to beta1 = 1
out.biased = rep.sample(x, true.par = c(2,1,4), omit = 2) # omit x2
mean(out.biased$coef["beta1",]) # not approx. equal to beta1 = 1
out.biased$bias.coef # show the true bias in coefficients
# Simulate a regression with given correlation structure in exogenous data
corr.mat = cbind(c(1, 0.9),c(0.9, 1)) # Generate desired correlation structure (high autocorrelation)
X = makedata.corr(n = 10, k = 2, CORR = corr.mat) # Generate 10 observations of 2 exogenous variables
out = rep.sample(X, true.par = c(2,1,4), rep = 1) # Simulate a regression
out$vcov.coef
# Illustrate confidence intervals
out = rep.sample(c(10, 20, 30,50), true.par = c(0.2,0.13), rep = 10, seed = 12)
plot(out, plot.what = "confint")
# Plots confidence intervals of alpha with specified \code{xlim} values.
plot(out, plot.what = "confint", which.coef = 1, xlim = c(-15,15))
# Illustrate normalitly of dependent variable
out = rep.sample(c(10,30,50), true.par = c(0.2,0.13), rep = 200)
plot(out, plot.what = "scatter")
# Illustrate confidence bands in a regression
plot(out, plot.what = "reglines")
# Numerical illustration 14.2. of the textbook
X <- reset.test(milk ~ feed, m = 4, data = data.milk)
X
# Plot the test result
plot(X)
names(X)
print(X,details = T)
MyPath <- file.path(.libPaths()[1], "desk", "Labor.txt")
showfile(MyPath) # show everything
showfile(MyPath, head = 4) # show only first 4 lines
x = c(1,2)
y = c(4,1)
Sxy(x) # variation
Sxy(x,y) # covariation
# Second example illustrating the na.rm option
x = c(1,2,NA,4)
Sxy(x)
Sxy(x, na.rm = T)
fert.est <- ols(barley ~ phos + nit, data = log(data.fertilizer))
x = t.coef.test(fert.est, nh = c(0,1,1), q = 1, details = T)
x # Show the test results
plot(x) # Visualize the test result
# Test H1: "phos > 0.5"
x = t.coef.test(fert.est, nh = c(0,1,0), q = 0.5, dir = "right")
plot(x)
names(x)
x$nh
X <- wh.test(wage ~ educ + age, data = data.wage)
# Show the auxiliary regression results
X$hreg
# Prettier way
print(X, details = T)
# Plot the test result
plot(X)
